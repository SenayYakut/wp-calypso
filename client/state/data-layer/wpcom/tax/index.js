/** @format */

/**
 * External dependencies
 */
import { get, isEmpty, keyBy, mapValues } from 'lodash';

/**
 * Internal dependencies
 */
import { dispatchRequestEx } from 'state/data-layer/wpcom-http/utils';
// import { http } from 'state/data-layer/wpcom-http/actions';
import { PAYMENT_COUNTRY_CODE_SET, PAYMENT_TAX_RATE_REQUEST } from 'state/action-types';
import { recordTracksEventWithClientId as recordTracksEvent } from 'state/analytics/actions';
import config from 'config';
import debug from 'debug';
import {
	setPaymentTaxRate,
	setPaymentPostalCode,
	setPaymentCountryCode,
	requestPaymentTaxRate,
} from 'state/ui/payment/actions';
import { registerHandlers } from 'state/data-layer/handler-registry';
import getPaymentCountryCode from 'state/selectors/get-payment-country-code';
import getPaymentPostalCode from 'state/selectors/get-payment-postal-code';
import { convertToSnakeCase } from 'state/data-layer/utils';
import { isValidPostalCode } from 'lib/postal-code';

const log = debug( 'calypso:daya-layer:tax' );

/**
 * Placeholders to use until real values are available from the API
 */
import { dummyTaxRate } from 'lib/tax';

/**
 * Flux Bridge
 *
 * This more properly belongs in a separate piece of middleware,
 * but it's sole purpose is to tap into flux data flows and produce
 * redux actions for the tax middleware.
 *
 * This lets us write the rest of the tax middleware as though these stores were
 * already converted to redux so we can switch easily later, and we avoid
 * compounding the flux problem.
 */
import { registerActionForward } from 'lib/redux-bridge';
registerActionForward( 'TRANSACTION_NEW_CREDIT_CARD_DETAILS_SET' );
registerActionForward( 'TRANSACTION_PAYMENT_SET' );

/**
 * Intercept TRANSACTION_PAYMENT_SET flux events, generated by clicking on
 * previously stored credit cards on the checkout screen.
 */

// Taxes the reduxStore and the flux action, and dispatches 0 or more redux
// actions.
export const handleFluxTransactionNewCreditCardDetailsSet = ( store, action ) => {
	setIfChanged( store, {
		// The UI already propagates the country code through redux, so we don't here.
		postalCode: get( action, 'rawDetails.postal-code' ),
	} );
};

// Taxes the reduxStore and the flux action, and dispatches 0 or more redux
// actions.
export const handleFluxTransactionPaymentSet = ( store, action ) => {
	// Returns an empty object if the meta if it can't find the meta
	// [ { meta_key: foo, meta_value: bar }, ... ] -> { foo: bar, ... }
	const metaObject = mapValues(
		keyBy( get( action, 'payment.storedCard.meta' ), 'meta_key' ),
		'meta_value'
	);
	if ( isEmpty( metaObject ) ) {
		return;
	}

	setIfChanged( store, {
		postalCode: metaObject.card_zip,
		countryCode: metaObject.country_code,
	} );
	return;
};

export function setIfChanged( { dispatch, getState }, { countryCode, postalCode } ) {
	const state = getState();

	if ( countryCode !== undefined && countryCode !== getPaymentCountryCode( state ) ) {
		dispatch( setPaymentCountryCode( countryCode ) );
		dispatch( requestPaymentTaxRate() );
	}

	if ( postalCode !== undefined && postalCode !== getPaymentPostalCode( state ) ) {
		dispatch( setPaymentPostalCode( postalCode ) );
		dispatch( requestPaymentTaxRate() );
	}
}

/**
 * Tax Middleware
 *
 * Monitor payment country and postcode values and fetch and store tax rates
 * in the redux store as appropriate.
 */

export const receiveSuccess = ( action, data ) => {
	const taxRate = get( data, 'combined_rate' );
	log( 'received tax rate', taxRate, data );
	const tracksData = {
		postal_code: action.postalCode,
		country_code: action.countryCode,
		tax_rate: taxRate,
		source_action: JSON.stringify( action ),
	};
	return [
		recordTracksEvent( 'calypso_tax_rate_request_success', tracksData ),
		setPaymentTaxRate( taxRate ),
	];
};

export const receiveError = ( action, { error: code, message } ) => [
	recordTracksEvent( 'calypso_tax_rate_request_error', {
		error_code: code,
		error_message: message,
		source_action: JSON.stringify( action ),
	} ),
];

export const fetchTaxRate = action => ( dispatch, getState ) => {
	// We need to return a thunk here to get missing fields out of the state,
	// but if we can have the source  action pass the postalCode + countryCode
	// we can drop that extra `(dispatch, getState) => ...` and simplify things
	// here

	const state = getState();
	const postalCode = get( action, 'postalCode' ) || getPaymentPostalCode( state );
	if ( ! postalCode ) {
		log( 'no postalCode' );
		return [];
	}

	if ( ! isValidPostalCode( postalCode ) ) {
		log( 'invalid postal code', postalCode );
		return [];
	}

	// PAYMENT_COUNTRY_CODE_SET is wired up alongside
	// FLUX_TRANSACTION_NEW_CREDIT_CARD_DETAILS_SET, but fires first, so we need
	// to fire on it, but only when it's a change.
	const previousCountryCode = getPaymentCountryCode( state );
	if ( action.type === PAYMENT_COUNTRY_CODE_SET && action.countryCode === previousCountryCode ) {
		log( 'country unchanged', action.countryCode );
		return [];
	}
	const countryCode = action.countryCode || previousCountryCode;
	const countriesWithTaxEnabled = { US: true };
	if ( ! countriesWithTaxEnabled[ countryCode ] ) {
		log( 'country not enabled', countryCode );
		return [];
	}

	log( 'fetching tax rate', countryCode, postalCode );

	// Placeholder until the http request will trigger this
	if ( config.isEnabled( 'show-tax' ) ) {
		setTimeout( () =>
			receiveSuccess( action, { combined_rate: dummyTaxRate( postalCode, countryCode ) } ).map(
				dispatch
			)
		);
	}

	const tracksData = convertToSnakeCase( {
		countryCode,
		postalCode,
		source_action: JSON.stringify( action ),
	} );
	return (
		[
			// Note: Once we get a path, we need to:
			// 1. move this file into the matching directory
			// 2. update the registerHandlers() call below,
			// 3. update the import in client/state/ui/payment/actions.js
			//
			// http(
			// 	{
			// 		path: ???,
			// 		method: 'GET',
			// 	},
			// 	action
			// ),
			// TEMP: this belongs in the form, or at least in it's own middleware
			// setPaymentPostalcode( postalCode ),
			recordTracksEvent( 'calypso_tax_rate_request', tracksData ),
		]
			// if we drop the thunk we should be able to skip this dispatch step,
			// return the plain array, and let dispatchRequestEx work it's magic.
			.map( dispatch )
	);
};

const fetchTaxRateRequest = dispatchRequestEx( {
	fetch: fetchTaxRate,
	onSuccess: receiveSuccess,
	onError: receiveError,
} );

registerHandlers( 'state/data-layer/wpcom/tax/index.js', {
	[ PAYMENT_TAX_RATE_REQUEST ]: [ fetchTaxRateRequest ],
	[ PAYMENT_COUNTRY_CODE_SET ]: [ fetchTaxRateRequest ],
	[ 'FLUX_TRANSACTION_NEW_CREDIT_CARD_DETAILS_SET' ]: [
		handleFluxTransactionNewCreditCardDetailsSet,
	],
	[ 'FLUX_TRANSACTION_PAYMENT_SET' ]: [ handleFluxTransactionPaymentSet ],
} );
